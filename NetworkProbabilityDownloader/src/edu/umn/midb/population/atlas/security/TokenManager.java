package edu.umn.midb.population.atlas.security;

import java.util.ArrayList;
import java.util.Random;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import edu.umn.midb.population.atlas.base.ApplicationContext;
import edu.umn.midb.population.atlas.servlet.NetworkProbabilityDownloader;
import edu.umn.midb.population.atlas.utils.AtlasDataCacheManager;
import edu.umn.midb.population.atlas.utils.EmailNotifier;
import edu.umn.midb.population.atlas.utils.SMSNotifier;
import edu.umn.midb.population.atlas.utils.Utils;
import logs.ThreadLocalLogTracker;

/**
 * Each user has a TokenManager for the life of the user's web session. Of course,
 * the token is useless unless the user knows the password required to gain access
 * to the Admin Console. Even if a user hacks the html page and changes the non-diplay
 * layers to visible, none of the functionality will work if the user has not validated
 * the token via the password. The token generated by this class has a very limited life
 * span and will expired in usually 30 seconds or less. This heightens the level of
 * security provided by only password protection.
 * 
 * @author jjfair
 *
 */
public class TokenManager {

	private static String password = null;
	private static String encPassword = null;
	private static String key = null;
	private String currentToken = null;
	private long tokenGenerationTime = 0;
	private boolean tokenExpired = false;
	private boolean accessDenied = false;
	private boolean invalidIP = false;
	private boolean validPassword = false;
	private ApplicationContext appContext = null;
	private static long MAX_ELAPSED_TIME_MS = 30000;
	private static Logger LOGGER = LogManager.getLogger(TokenManager.class);
	private static String INIT_LOGGER_ID = " ::LOGGERID=TokenManager:: ";
	private static ArrayList<String> privilegedList = AtlasDataCacheManager.getInstance().getPrivilegedList();
	
	static {
		LOGGER.trace(privilegedList);
	}
	
	/**
	 * Public constructor
	 * 
	 * @param appContext - {@link ApplicationContext}
	 * @param ipAddress - Sting which is the ipAddress of the remote client
	 */
	public TokenManager(ApplicationContext appContext, String ipAddress) {
		this.appContext = appContext;
		this.generateToken();
		
		if(!privilegedList.contains(ipAddress)) {
			this.invalidIP = true;
		}
	}
	/**
	 * 
	 * Generates a new token which will expire in MAX_ELAPSED_TIME_MS
	 */
	private void generateToken() {
			
		    int leftLimit = 97; // letter 'a'
		    int rightLimit = 122; // letter 'z'
		    int targetStringLength = 10;
		    Random random = new Random();

		    String token = random.ints(leftLimit, rightLimit + 1)
		      .limit(targetStringLength)
		      .collect(StringBuilder::new, StringBuilder::appendCodePoint, StringBuilder::append)
		      .toString();

		    this.currentToken = token;
		    this.tokenGenerationTime = System.currentTimeMillis();
	}
	
	/**
	 * Returns the currentToken.
	 * 
	 * @return currentToken - String
	 */
	public String getToken() {
		return this.currentToken;
	}
	
	/**
	 * Examines the token to verify that it is not expired. It also verifies that
	 * the password entered is valid and that the ipAddress of the client is in the
	 * access control list (acl.conf).
	 * 
	 * @param token - String
	 * @param passwordParm - String
	 * @param ipAddress - String
	 * 
	 * @return isValid - boolean
	 */
	public boolean validateToken(String token, String passwordParm, String ipAddress) {
		String loggerId = ThreadLocalLogTracker.get();
		LOGGER.trace(loggerId + "validateToken()...invoked, ipAddress=" + ipAddress);

		boolean isValid = false;
		
		String localHostName = AtlasDataCacheManager.getInstance().getLocalHostName();
		if(localHostName.contains("JAMESs-MacBook-Pro")) {
			if(ipAddress.equals("127.0.0.1")) {
				isValid = true;
			}
		}
		
		else if(!privilegedList.contains(ipAddress)) {
			LOGGER.trace(loggerId + "validateToken()...ipAddress not in acl.conf.");
			EmailNotifier.sendEmailNotification("Illegal access warning, ip address=" + ipAddress);
			String currentAction = this.appContext.getCurrentAction();
			String message = "MIDB_APP_POTENTIAL_HACKER::::" + NetworkProbabilityDownloader.getDomainName();
			message += "::::IP_ADDRESS=" + ipAddress + "::::";
			message += "ACTION=" + currentAction;
			SMSNotifier.sendNotification(message, "TokenManager");
			
			this.accessDenied = true;
			this.invalidIP = true;
			return false;
		}
		
		if(this.currentToken==null) {
			return false;
		}
		
		isValid = false;
		long currentTimeMS = System.currentTimeMillis();
		long lapsedTimeMS = currentTimeMS - this.tokenGenerationTime;
		LOGGER.trace(loggerId + "lapsedTimeMS=" + lapsedTimeMS);
		
		if(this.currentToken.contentEquals(token)) {
			if(lapsedTimeMS < MAX_ELAPSED_TIME_MS) {
				if(passwordParm.contentEquals(password)) {
					isValid = true;
					this.validPassword = true;
					this.currentToken = null;
				}
				else {
					this.validPassword = false;
					LOGGER.trace(loggerId + "validateToken()...incorrect password:" + passwordParm);
				}
			}
			else {
				this.tokenExpired = true;
			}
		}
		LOGGER.trace(loggerId + "validateToken()...exit.");
		return isValid;
	}
	
	/**
	 * Returns a boolean indicating if the currentToken is expired.
	 *  
	 * @return tokenExpired - boolean
	 */
	public boolean isTokenExpired() {
		return this.tokenExpired;
	}
	
	/**
	 * 
	 * Returns a boolean indicating if access was denied due to an ip address not in
	 * the access control list (acl.conf)
	 * 
	 * @return accessDenied - boolean
	 */
	public boolean isAccessDenied() {
		return this.accessDenied;
	}
	
	/**
	 * 
	 * Sets the key used to decrypt the password
	 * 
	 * @param keyString - String
	 */
	public static void setKey(String keyString) {
		LOGGER.trace(INIT_LOGGER_ID + "setKey()...invoked.");
		key = keyString;
		if(password==null && encPassword != null) {
			password = Utils.convertJcpyt(encPassword, key);
		}
		LOGGER.trace(INIT_LOGGER_ID + "setKey()...exit.");
	}
	
	/**
	 * Sets the current password being used for access to the Admin Console.
	 * 
	 * @param encryptedPassword - String
	 */
	public static void setPassword(String encryptedPassword) {
		encPassword = encryptedPassword;
		
		if(key != null) {
			password = Utils.convertJcpyt(encryptedPassword, key);
		}
	}
	
	/**
	 * Returns a boolean indicating if the ip address of the remote client is invalid, 
	 * meaning that it is not in the access control list (acl.conf).
	 * 
	 * @return invalidIP - boolean
	 */
	public boolean isInvalidIP() {
		return invalidIP;
	}

	/**
	 * Returns a boolean indicating if the ip address of the remote client is contained
	 * in the access control list (acl.conf).
	 * 
	 * @return valid - boolean
	 */
	public boolean isValidIP() {
		boolean valid = !this.invalidIP;
		return valid;
	}
	
	/**
	 * Returns a boolean indicating if the password provided is valid.
	 * 
	 * @return validPassword - boolean
	 */
	public boolean isValidPassword() {
		return this.validPassword;
	}
	
}
