package edu.umn.midb.population.atlas.security;

import java.util.Random;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import edu.umn.midb.population.atlas.base.ApplicationContext;
import edu.umn.midb.population.atlas.data.access.AtlasDataCacheManager;
import edu.umn.midb.population.atlas.utils.Utils;
import logs.ThreadLocalLogTracker;

/**
 * Each user has a TokenManager for the life of the user's web session. Of course,
 * the token is useless unless the user knows the password required to gain access
 * to the Admin Console. Even if a user hacks the html page and changes the non-diplay
 * layers to visible, none of the functionality will work if the user has not validated
 * the token via the password. The token generated by this class has a very limited life
 * span and will expired in usually 30 seconds or less. This heightens the level of
 * security provided by only password protection.
 * 
 * @author jjfair
 *
 */
public class TokenManager {

	private static String password = null;
	private static String encPassword = null;
	private static String key = null;
	private static long MAX_ELAPSED_TIME_MS = 60000;
	private static Logger LOGGER = LogManager.getLogger(TokenManager.class);
	private static String INIT_LOGGER_ID = " ::LOGGERID=TokenManager:: ";
	private String currentToken = null;
	private boolean currentTokenAlreadyUsed = false;
	private long tokenGenerationTime = 0;
	
	private boolean tokenExpired = false;
	
	private boolean validPassword = false;
	private ApplicationContext appContext = null;
	
	
	/**
	 * 
	 * Sets the key used to decrypt the password
	 * 
	 * @param keyString - String
	 */
	public static void setKey(String keyString) {
		LOGGER.trace(INIT_LOGGER_ID + "setKey()...invoked.");
		key = keyString;
		if(password==null && encPassword != null) {
			password = Utils.convertJcpyt(encPassword, key);
		}
		LOGGER.trace(INIT_LOGGER_ID + "setKey()...exit.");
	}
	/**
	 * Sets the current password being used for access to the Admin Console.
	 * 
	 * @param encryptedPassword - String
	 */
	public static void setPassword(String encryptedPassword) {
		encPassword = encryptedPassword;
		
		if(key != null) {
			password = Utils.convertJcpyt(encryptedPassword, key);
		}
	}

	
	/**
	 * Public constructor
	 * 
	 * @param appContext - {@link ApplicationContext}
	 * @param ipAddress - Sting which is the ipAddress of the remote client
	 */
	public TokenManager(ApplicationContext appContext, String ipAddress) {
		this.setAppContext(appContext);
		this.generateToken();
		
		/*
		if(!privilegedList.contains(ipAddress)) {
			this.invalidIP = true;
		}
		*/
	}
	
	/**
	 * 
	 * Generates a new token which will expire in MAX_ELAPSED_TIME_MS
	 */
	private void generateToken() {
			
		    int leftLimit = 97; // letter 'a'
		    int rightLimit = 122; // letter 'z'
		    int targetStringLength = 10;
		    Random random = new Random();

		    String token = random.ints(leftLimit, rightLimit + 1)
		      .limit(targetStringLength)
		      .collect(StringBuilder::new, StringBuilder::appendCodePoint, StringBuilder::append)
		      .toString();

		    this.currentToken = token;
		    this.tokenGenerationTime = System.currentTimeMillis();
	}
	
	/**
	 * Returns the {@link ApplicationContext}
	 * 
	 * @return appContext - ApplicationContext
	 */
	public ApplicationContext getAppContext() {
		return appContext;
	}
	
	/**
	 * Returns the currentToken.
	 * 
	 * @return currentToken - String
	 */
	public String getToken() {
		return this.currentToken;
	}
	
	/**
	 * Returns a boolean indicating if the currentToken is expired.
	 *  
	 * @return tokenExpired - boolean
	 */
	public boolean isTokenExpired() {
		return this.tokenExpired;
	}
	
	/**
	 * Returns a boolean indicating if the password provided is valid.
	 * 
	 * @return validPassword - boolean
	 */
	public boolean isValidPassword() {
		return this.validPassword;
	}
	
	/**
	 * Sets the {@link ApplicationContext}
	 * 
	 * @param appContext - ApplicationContext
	 */
	public void setAppContext(ApplicationContext appContext) {
		this.appContext = appContext;
	}
	
	/**
	 * Examines the token to verify that it is not expired. It also verifies that
	 * the password entered is valid 
	 * 
	 * @param token - String
	 * @param passwordParm - String
	 * @param ipAddress - String
	 * 
	 * @return isValid - boolean
	 */
	public boolean validateToken(String tokenParm, String passwordParm, String ipAddress) {
		String loggerId = ThreadLocalLogTracker.get();
		LOGGER.trace(loggerId + "validateToken()...invoked, ipAddress=" + ipAddress);

		boolean isValid = false;
		
		String localHostName = AtlasDataCacheManager.getInstance().getLocalHostName();
		if(localHostName.contains("JAMESs-MacBook-Pro")) {
			if(ipAddress.equals("127.0.0.1")) {
				isValid = true;
			}
		}
		
		if(this.currentToken==null || tokenParm==null) { //null tokenParm indicates hack attempt
			return false;
		}
		if(passwordParm==null) { //indicates hack attempt
			this.validPassword = false;
			return false;
		}
		
		isValid = false;
		long currentTimeMS = System.currentTimeMillis();
		long lapsedTimeMS = currentTimeMS - this.tokenGenerationTime;
		LOGGER.trace(loggerId + "lapsedTimeMS=" + lapsedTimeMS);
		
		if(this.currentToken.contentEquals(tokenParm)) {
			if(lapsedTimeMS < MAX_ELAPSED_TIME_MS && !this.currentTokenAlreadyUsed) {
				if(passwordParm.contentEquals(password)) {
					isValid = true;
					this.validPassword = true;
					this.currentTokenAlreadyUsed = true;
				}
				else {
					this.validPassword = false;
					LOGGER.trace(loggerId + "validateToken()...incorrect password:" + passwordParm);
				}
			}
			else {
				this.tokenExpired = true;
			}
		}
		LOGGER.trace(loggerId + "validateToken()...exit.");
		return isValid;
	}
	
}
